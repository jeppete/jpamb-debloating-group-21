jpamb.cases.AbstractInterpreterCases.arithmeticConstraints:(I)I (10) -> ok
jpamb.cases.AbstractInterpreterCases.arithmeticConstraints:(I)I (20) -> ok
jpamb.cases.AbstractInterpreterCases.arrayBoundsTracking:(I)I (10) -> ok
jpamb.cases.AbstractInterpreterCases.arrayBoundsTracking:(I)I (5) -> ok
jpamb.cases.AbstractInterpreterCases.booleanValueTracking:(Z)I (false) -> ok
jpamb.cases.AbstractInterpreterCases.booleanValueTracking:(Z)I (true) -> ok
jpamb.cases.AbstractInterpreterCases.chainedComparisons:(I)I (7) -> ok
jpamb.cases.AbstractInterpreterCases.chainedComparisons:(I)I (8) -> ok
jpamb.cases.AbstractInterpreterCases.complexArithmetic:(I)I  (3) -> ok
jpamb.cases.AbstractInterpreterCases.complexArithmetic:(I)I  (7) -> ok
jpamb.cases.AbstractInterpreterCases.constantPropagation:()I () -> ok
jpamb.cases.AbstractInterpreterCases.contradictoryConditions:(I)I (15) -> ok
jpamb.cases.AbstractInterpreterCases.contradictoryConditions:(I)I (5) -> ok
jpamb.cases.AbstractInterpreterCases.divisionByZeroTracking:(I)I (10) -> ok
jpamb.cases.AbstractInterpreterCases.divisionByZeroTracking:(I)I (5) -> ok
jpamb.cases.AbstractInterpreterCases.loopInvariant:(I)I      (5) -> ok
jpamb.cases.AbstractInterpreterCases.moduloAnalysis:(I)I     (10) -> ok
jpamb.cases.AbstractInterpreterCases.moduloAnalysis:(I)I     (11) -> ok
jpamb.cases.AbstractInterpreterCases.multipleConstraints:(I)I (12) -> ok
jpamb.cases.AbstractInterpreterCases.multipleConstraints:(I)I (8) -> ok
jpamb.cases.AbstractInterpreterCases.nestedValueDependencies:(I)I (6) -> ok
jpamb.cases.AbstractInterpreterCases.nestedValueDependencies:(I)I (8) -> ok
jpamb.cases.AbstractInterpreterCases.oldClassicCheck:(I)I    (15) -> ok
jpamb.cases.AbstractInterpreterCases.oldClassicCheck:(I)I    (5) -> ok
jpamb.cases.AbstractInterpreterCases.positiveNotZero:(I)I    (-5) -> ok
jpamb.cases.AbstractInterpreterCases.positiveNotZero:(I)I    (5) -> ok
jpamb.cases.AbstractInterpreterCases.rangeAnalysis:(I)I      (3) -> ok
jpamb.cases.AbstractInterpreterCases.rangeAnalysis:(I)I      (7) -> ok
jpamb.cases.AbstractInterpreterCases.signContradiction:(I)I  (-5) -> ok
jpamb.cases.AbstractInterpreterCases.signContradiction:(I)I  (5) -> ok
jpamb.cases.AbstractInterpreterCases.squareCheck:(I)I        (16) -> ok
jpamb.cases.AbstractInterpreterCases.squareCheck:(I)I        (4) -> ok
jpamb.cases.AbstractInterpreterCases.squareCheck:(I)I        (5) -> ok
jpamb.cases.AbstractInterpreterCases.squareCheck:(I)I        (9) -> ok
jpamb.cases.AbstractInterpreterCases.valuePropagation:(I)I   (0) -> assertion error
jpamb.cases.AbstractInterpreterCases.valuePropagation:(I)I   (5) -> ok
jpamb.cases.Arrays.arrayContent:()V                          () -> assertion error
jpamb.cases.Arrays.arrayInBounds:()V                         () -> ok
jpamb.cases.Arrays.arrayIsNull:()V                           () -> null pointer
jpamb.cases.Arrays.arrayIsNullLength:()V                     () -> null pointer
jpamb.cases.Arrays.arrayLength:()V                           () -> ok
jpamb.cases.Arrays.arrayNotEmpty:([I)V                       ([I:1]) -> ok
jpamb.cases.Arrays.arrayNotEmpty:([I)V                       ([I:]) -> assertion error
jpamb.cases.Arrays.arrayOutOfBounds:()V                      () -> out of bounds
jpamb.cases.Arrays.arraySometimesNull:(I)V                   (0) -> out of bounds
jpamb.cases.Arrays.arraySometimesNull:(I)V                   (11) -> null pointer
jpamb.cases.Arrays.arraySpellsHello:([C)V                    ([C:'h', 'e', 'l', 'l', 'o']) -> ok
jpamb.cases.Arrays.arraySpellsHello:([C)V                    ([C:'x']) -> assertion error
jpamb.cases.Arrays.arraySpellsHello:([C)V                    ([C:]) -> out of bounds
jpamb.cases.Arrays.arraySumIsLarge:([I)V                     ([I:50, 100, 200]) -> ok
jpamb.cases.Arrays.arraySumIsLarge:([I)V                     ([I:]) -> assertion error
jpamb.cases.Arrays.binarySearch:(I)V                         (3) -> ok
jpamb.cases.Arrays.binarySearch:(I)V                         (6) -> assertion error
jpamb.cases.Calls.allPrimesArePositive:(I)V                  (-1) -> assertion error
jpamb.cases.Calls.allPrimesArePositive:(I)V                  (0) -> out of bounds
jpamb.cases.Calls.allPrimesArePositive:(I)V                  (100) -> ok
jpamb.cases.Calls.assertFalse:()V                            () -> assertion error
jpamb.cases.Calls.assertIf:(Z)V                              (false) -> assertion error
jpamb.cases.Calls.assertIf:(Z)V                              (true) -> ok
jpamb.cases.Calls.assertTrue:()V                             () -> ok
jpamb.cases.Calls.callsAssertFalse:()V                       () -> assertion error
jpamb.cases.Calls.callsAssertFib:(I)V                        (0) -> assertion error
jpamb.cases.Calls.callsAssertFib:(I)V                        (8) -> ok
jpamb.cases.Calls.callsAssertIf:(Z)V                         (false) -> assertion error
jpamb.cases.Calls.callsAssertIf:(Z)V                         (true) -> ok
jpamb.cases.Calls.callsAssertIfWithTrue:()V                  () -> ok
jpamb.cases.Calls.callsAssertTrue:()V                        () -> ok
jpamb.cases.Calls.fib:(I)I                                   (-1) -> assertion error
jpamb.cases.Calls.fib:(I)I                                   (0) -> ok
jpamb.cases.Calls.fib:(I)I                                   (1) -> ok
jpamb.cases.Calls.fib:(I)I                                   (8) -> ok
jpamb.cases.Calls.generatePrimeArray:(I)[I                   (-1) -> assertion error
jpamb.cases.Calls.generatePrimeArray:(I)[I                   (0) -> assertion error
jpamb.cases.Calls.generatePrimeArray:(I)[I                   (1) -> ok
jpamb.cases.Calls.generatePrimeArray:(I)[I                   (5) -> ok
jpamb.cases.Debloating.allBranchesExit:(IZ)I                 (0, true) -> divide by zero
jpamb.cases.Debloating.allBranchesExit:(IZ)I                 (5, false) -> ok
jpamb.cases.Debloating.allBranchesExit:(IZ)I                 (5, true) -> ok
jpamb.cases.Debloating.constantConditionBlocks:(I)I          (0) -> assertion error
jpamb.cases.Debloating.constantConditionBlocks:(I)I          (10) -> ok
jpamb.cases.Debloating.constantConditionDead:(I)I            (10) -> ok
jpamb.cases.Debloating.constantConditionDead:(I)I            (5) -> ok
jpamb.cases.Debloating.deadCodeAfterReturn:(I)I              (0) -> assertion error
jpamb.cases.Debloating.deadCodeAfterReturn:(I)I              (5) -> ok
jpamb.cases.Debloating.emptyFinally:(I)I                     (-5) -> ok
jpamb.cases.Debloating.emptyFinally:(I)I                     (5) -> ok
jpamb.cases.Debloating.redundantChecks:(I)I                  (0) -> assertion error
jpamb.cases.Debloating.redundantChecks:(I)I                  (5) -> ok
jpamb.cases.Debloating.switchDeadCases:(I)I                  (1) -> ok
jpamb.cases.Debloating.switchDeadCases:(I)I                  (2) -> ok
jpamb.cases.Debloating.switchEmptyFallthrough:(I)I           (1) -> ok
jpamb.cases.Debloating.switchEmptyFallthrough:(I)I           (2) -> ok
jpamb.cases.Debloating.switchEmptyFallthrough:(I)I           (3) -> ok
jpamb.cases.Debloating.unreachableCatch:(I)I                 (0) -> divide by zero
jpamb.cases.Debloating.unreachableCatch:(I)I                 (5) -> ok
jpamb.cases.Debloating.unusedHelper:(I)I                     (0) -> assertion error
jpamb.cases.Debloating.unusedHelper:(I)I                     (3) -> ok
jpamb.cases.Debloating.unusedParameter:(II)I                 (0, 20) -> assertion error
jpamb.cases.Debloating.unusedParameter:(II)I                 (5, 10) -> ok
jpamb.cases.Debloating.unusedVariables:(I)I                  (0) -> assertion error
jpamb.cases.Debloating.unusedVariables:(I)I                  (4) -> ok
jpamb.cases.Dependent.badNormalizedDistance:(II)I            (0, 0) -> divide by zero
jpamb.cases.Dependent.badNormalizedDistance:(II)I            (1, 1) -> ok
jpamb.cases.Dependent.divisionLoop:(I)V                      (0) -> ok
jpamb.cases.Dependent.divisionLoop:(I)V                      (1) -> ok
jpamb.cases.Dependent.normalizedDistance:(II)I               (0, 0) -> ok
jpamb.cases.Dependent.safeDivByN:(I)I                        (0) -> ok
jpamb.cases.Dependent.safeDivByN:(I)I                        (1) -> ok
jpamb.cases.Loops.forever:()V                                () -> *
jpamb.cases.Loops.neverAsserts:()V                           () -> *
jpamb.cases.Loops.neverDivides:()I                           () -> *
jpamb.cases.Loops.terminates:()V                             () -> assertion error
jpamb.cases.Simple.assertBoolean:(Z)V                        (false) -> assertion error
jpamb.cases.Simple.assertBoolean:(Z)V                        (true) -> ok
jpamb.cases.Simple.assertFalse:()V                           () -> assertion error
jpamb.cases.Simple.assertInteger:(I)V                        (0) -> assertion error
jpamb.cases.Simple.assertInteger:(I)V                        (1) -> ok
jpamb.cases.Simple.assertPositive:(I)V                       (-1) -> assertion error
jpamb.cases.Simple.assertPositive:(I)V                       (1) -> ok
jpamb.cases.Simple.checkBeforeAssert:(I)V                    (-1) -> assertion error
jpamb.cases.Simple.checkBeforeAssert:(I)V                    (0) -> ok
jpamb.cases.Simple.checkBeforeDivideByN2:(I)I                (0) -> ok
jpamb.cases.Simple.checkBeforeDivideByN2:(I)I                (1) -> ok
jpamb.cases.Simple.checkBeforeDivideByN:(I)I                 (0) -> assertion error
jpamb.cases.Simple.checkBeforeDivideByN:(I)I                 (1) -> ok
jpamb.cases.Simple.divideByN:(I)I                            (0) -> divide by zero
jpamb.cases.Simple.divideByN:(I)I                            (1) -> ok
jpamb.cases.Simple.divideByNMinus10054203:(I)I               (0) -> ok
jpamb.cases.Simple.divideByNMinus10054203:(I)I               (10054203) -> divide by zero
jpamb.cases.Simple.divideByZero:()I                          () -> divide by zero
jpamb.cases.Simple.divideZeroByZero:(II)I                    (0, 0) -> divide by zero
jpamb.cases.Simple.divideZeroByZero:(II)I                    (0, 1) -> ok
jpamb.cases.Simple.earlyReturn:()I                           () -> ok
jpamb.cases.Simple.justAdd:(II)I                             (1, 2) -> ok
jpamb.cases.Simple.justMulitply:(II)I                        (1, 2) -> ok
jpamb.cases.Simple.justReturn:()I                            () -> ok
jpamb.cases.Simple.justReturnNothing:()V                     () -> ok
jpamb.cases.Simple.multiError:(Z)I                           (false) -> assertion error
jpamb.cases.Simple.multiError:(Z)I                           (true) -> divide by zero
jpamb.cases.Tricky.collatz:(I)V                              (0) -> assertion error
jpamb.cases.Tricky.collatz:(I)V                              (24) -> ok